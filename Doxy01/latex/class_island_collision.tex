\hypertarget{class_island_collision}{}\section{Island\+Collision Class Reference}
\label{class_island_collision}\index{Island\+Collision@{Island\+Collision}}


{\ttfamily \#include $<$Island\+Collision.\+h$>$}



Collaboration diagram for Island\+Collision\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=159pt]{class_island_collision__coll__graph}
\end{center}
\end{figure}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static bool \hyperlink{class_island_collision_a78e4fc740b5676ec2470fb3bd06e7fb7}{Check} (\hyperlink{structm_a_a_b_b}{m\+A\+A\+BB} a, \hyperlink{structm_a_a_b_b}{m\+A\+A\+BB} b)
\begin{DoxyCompactList}\small\item\em Checks if one A\+A\+BB is colliding with another, true if colliding. \end{DoxyCompactList}\item 
static bool \hyperlink{class_island_collision_a47b13bd9de6d0f242abf93c3345dec09}{Check} (\hyperlink{structm_a_a_b_b}{m\+A\+A\+BB} box, std\+::vector$<$ \hyperlink{structm_a_a_b_b}{m\+A\+A\+BB} $>$ list, int list\+Size)
\begin{DoxyCompactList}\small\item\em Checks if one A\+A\+BB is colliding with any in a list of A\+A\+B\+Bs, true if colliding. \end{DoxyCompactList}\item 
static \hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3} \hyperlink{class_island_collision_a13a92119f2cca425c2bc886c0fc7ca75}{Resolve} (\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3} to\+Move\+Origin, \hyperlink{structm_a_a_b_b}{m\+A\+A\+BB} to\+Move\+BB, std\+::vector$<$ \hyperlink{structm_a_a_b_b}{m\+A\+A\+BB} $>$ list, int list\+Size, float inc\+Size)
\begin{DoxyCompactList}\small\item\em Given the current origin of an A\+A\+BB, returns the new origin for it that will resolve the collision with any static objects. Uses the island collision method. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 10 of file Island\+Collision.\+h.



\subsection{Member Function Documentation}
\index{Island\+Collision@{Island\+Collision}!Check@{Check}}
\index{Check@{Check}!Island\+Collision@{Island\+Collision}}
\subsubsection[{\texorpdfstring{Check(m\+A\+A\+B\+B a, m\+A\+A\+B\+B b)}{Check(mAABB a, mAABB b)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Island\+Collision\+::\+Check (
\begin{DoxyParamCaption}
\item[{{\bf m\+A\+A\+BB}}]{a, }
\item[{{\bf m\+A\+A\+BB}}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_island_collision_a78e4fc740b5676ec2470fb3bd06e7fb7}{}\label{class_island_collision_a78e4fc740b5676ec2470fb3bd06e7fb7}


Checks if one A\+A\+BB is colliding with another, true if colliding. 


\begin{DoxyParams}{Parameters}
{\em a} & First A\+A\+BB\\
\hline
{\em b} & Second A\+A\+BB\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool
\end{DoxyReturn}


Definition at line 5 of file Island\+Collision.\+cpp.



References Intersects().


\begin{DoxyCode}
6 \{
7     \textcolor{keywordflow}{if} (\hyperlink{_primitive_collisions_8h_a5c8dd515ea8f5209f058e607ac2a6d02}{Intersects}(a, b))
8     \{
9         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
10     \}
11     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
12 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=288pt]{class_island_collision_a78e4fc740b5676ec2470fb3bd06e7fb7_cgraph}
\end{center}
\end{figure}


\index{Island\+Collision@{Island\+Collision}!Check@{Check}}
\index{Check@{Check}!Island\+Collision@{Island\+Collision}}
\subsubsection[{\texorpdfstring{Check(m\+A\+A\+B\+B box, std\+::vector$<$ m\+A\+A\+B\+B $>$ list, int list\+Size)}{Check(mAABB box, std::vector< mAABB > list, int listSize)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Island\+Collision\+::\+Check (
\begin{DoxyParamCaption}
\item[{{\bf m\+A\+A\+BB}}]{box, }
\item[{std\+::vector$<$ {\bf m\+A\+A\+BB} $>$}]{list, }
\item[{int}]{list\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_island_collision_a47b13bd9de6d0f242abf93c3345dec09}{}\label{class_island_collision_a47b13bd9de6d0f242abf93c3345dec09}


Checks if one A\+A\+BB is colliding with any in a list of A\+A\+B\+Bs, true if colliding. 


\begin{DoxyParams}{Parameters}
{\em box} & First A\+A\+BB\\
\hline
{\em list} & List of A\+A\+B\+Bs\\
\hline
{\em list\+Size} & Size of A\+A\+BB list\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool
\end{DoxyReturn}


Definition at line 14 of file Island\+Collision.\+cpp.


\begin{DoxyCode}
15 \{
16 
17     \textcolor{comment}{//std::cout << "Checking collision with... MIN: " << a.min.x << "," << a.min.z << "," << a.min.z << ",
       MAX: " << a.max.x << "," << a.max.y << "," << a.max.z << "//  ";}
18 
19     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < listSize; i++)
20     \{
21         \textcolor{keywordflow}{if} (\hyperlink{_primitive_collisions_8h_a5c8dd515ea8f5209f058e607ac2a6d02}{Intersects}(a, list[i]))
22         \{
23             \textcolor{keywordflow}{return} \textcolor{keyword}{true};
24         \}
25     \}
26     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
27 \}
\end{DoxyCode}
\index{Island\+Collision@{Island\+Collision}!Resolve@{Resolve}}
\index{Resolve@{Resolve}!Island\+Collision@{Island\+Collision}}
\subsubsection[{\texorpdfstring{Resolve(vec3 to\+Move\+Origin, m\+A\+A\+B\+B to\+Move\+B\+B, std\+::vector$<$ m\+A\+A\+B\+B $>$ list, int list\+Size, float inc\+Size)}{Resolve(vec3 toMoveOrigin, mAABB toMoveBB, std::vector< mAABB > list, int listSize, float incSize)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf vec3} Island\+Collision\+::\+Resolve (
\begin{DoxyParamCaption}
\item[{{\bf vec3}}]{to\+Move\+Origin, }
\item[{{\bf m\+A\+A\+BB}}]{to\+Move\+BB, }
\item[{std\+::vector$<$ {\bf m\+A\+A\+BB} $>$}]{list, }
\item[{int}]{list\+Size, }
\item[{float}]{inc\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_island_collision_a13a92119f2cca425c2bc886c0fc7ca75}{}\label{class_island_collision_a13a92119f2cca425c2bc886c0fc7ca75}


Given the current origin of an A\+A\+BB, returns the new origin for it that will resolve the collision with any static objects. Uses the island collision method. 


\begin{DoxyParams}{Parameters}
{\em to\+Move\+Origin} & Origin of current bounding box to move when colliding\\
\hline
{\em to\+Move\+BB} & Current bounding box to move when colliding\\
\hline
{\em list} & List of A\+A\+B\+Bs\\
\hline
{\em list\+Size} & Size of A\+A\+BB list\\
\hline
{\em inc} & Size of movement increments\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
vec3
\end{DoxyReturn}


Definition at line 32 of file Island\+Collision.\+cpp.



References m\+A\+A\+B\+B\+::max, and m\+A\+A\+B\+B\+::min.


\begin{DoxyCode}
33 \{
34     \textcolor{comment}{// Increment between checks - initial distance and distance increase that occurs }
35     \textcolor{comment}{// when repeating the check in all directions when no escape is found.}
36     \textcolor{keywordtype}{float} increment = incSize;
37 
38     \textcolor{comment}{// The increment }
39     \textcolor{keywordtype}{float} dist = increment;
40 
41     \textcolor{comment}{// Set static var dirs if they have not been set up.}
42     \textcolor{comment}{// These are all the directions in which to check for an "escape route" from the collision.}
43     \textcolor{keywordflow}{if} (\hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.empty())
44     \{
45         \textcolor{comment}{// y = 0 layer}
46         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(1, 0, 0))); \textcolor{comment}{// x }
47         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(-1, 0, 0))); \textcolor{comment}{// -x}
48         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(0, 0, 1))); \textcolor{comment}{// z}
49         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(0, 0, -1))); \textcolor{comment}{//-z}
50         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(1, 0, 1))); \textcolor{comment}{// x z}
51         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(-1, 0, 1))); \textcolor{comment}{// -x z}
52         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(1, 0, -1))); \textcolor{comment}{// x -z}
53         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(-1, 0, -1))); \textcolor{comment}{// -x -z}
54 
55         \textcolor{comment}{// y = 1 layer}
56         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(1, 1, 0))); \textcolor{comment}{// x }
57         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(-1, 1, 0))); \textcolor{comment}{// -x}
58         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(0, 1, 1))); \textcolor{comment}{// z}
59         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(0, 1, -1))); \textcolor{comment}{//-z}
60         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(1, 1, 1))); \textcolor{comment}{// x z}
61         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(-1, 1, 1))); \textcolor{comment}{// -x z}
62         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(1, 1, -1))); \textcolor{comment}{// x -z}
63         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(-1, 1, -1))); \textcolor{comment}{// -x -z}
64 
65         \textcolor{comment}{// y = -1 layer}
66         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(1, -1, 0))); \textcolor{comment}{// x }
67         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(-1, -1, 0))); \textcolor{comment}{// -x}
68         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(0, -1, 1))); \textcolor{comment}{// z}
69         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(0, -1, -1))); \textcolor{comment}{//-z}
70         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(1, -1, 1))); \textcolor{comment}{// x z}
71         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(-1, -1, 1))); \textcolor{comment}{// -x z}
72         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(1, -1, -1))); \textcolor{comment}{// x -z}
73         \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.push\_back(normalize(\hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3}(-1, -1, -1))); \textcolor{comment}{// -x -z}
74     \}
75 
76     \textcolor{comment}{// If there is no collision to begin with}
77     \textcolor{keywordflow}{if} (!\hyperlink{class_island_collision_a78e4fc740b5676ec2470fb3bd06e7fb7}{Check}(toMoveBB, list, listSize))
78     \{
79         \textcolor{comment}{// Return the same position that was passed in}
80         \textcolor{keywordflow}{return} toMoveOrigin;
81     \}
82 
83     \textcolor{keywordflow}{while} (\textcolor{keyword}{true})
84     \{
85         \textcolor{comment}{// Go through each direction and check if you can find a way out of the collision in size
       increments, }
86         \textcolor{comment}{// increasing the size increment once you've checked the previous one in every direction.}
87         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < \hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}.size(); i++)
88         \{
89             \hyperlink{structm_a_a_b_b}{mAABB} box = toMoveBB;
90             \textcolor{comment}{// set final position to initial position}
91             \hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3} position = toMoveOrigin;
92             \textcolor{comment}{// get total difference to move the object and bounding box}
93             \hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3} diff = (\hyperlink{_island_collision_8cpp_aaaaa7b4cf9092c0cbadd963f4a7bc551}{dirs}[i] * dist); 
94 
95             \textcolor{comment}{// move object by difference                                      }
96             position += diff;
97             \textcolor{comment}{// move bounding box by difference}
98             box.\hyperlink{structm_a_a_b_b_af759d65b18f76e266945883107dcafc8}{min} += diff; 
99             box.\hyperlink{structm_a_a_b_b_a9866d0a5a3ceb5dbff2bf87372f3094a}{max} += diff;
100 
101             \textcolor{comment}{// If the object now isnt colliding with anything}
102             \textcolor{keywordflow}{if} (!\hyperlink{class_island_collision_a78e4fc740b5676ec2470fb3bd06e7fb7}{Check}(box, list, listSize))
103             \{
104                 \textcolor{comment}{//std::cout << "Item moved by " << diff.x << "," << diff.y << "," << diff.z << "\(\backslash\)n";}
105 
106                 \textcolor{comment}{// Return the final position}
107                 \textcolor{keywordflow}{return} (position);
108             \}
109         \}
110         dist += increment;
111 
112 
113         \textcolor{keywordflow}{if} (dist > increment * 1000)
114         \{
115             printf(\textcolor{stringliteral}{"Collision handling failed.\(\backslash\)n"});
116             \textcolor{keywordflow}{return} toMoveOrigin;
117         \}
118 
119     \}
120     
121 \}\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/elizabeth/\+Documents/\+Git\+Hub/\+Engine/\+Open\+G\+L\+Engine/\+Open\+G\+L\+Engine/\hyperlink{_island_collision_8h}{Island\+Collision.\+h}\item 
C\+:/\+Users/elizabeth/\+Documents/\+Git\+Hub/\+Engine/\+Open\+G\+L\+Engine/\+Open\+G\+L\+Engine/\hyperlink{_island_collision_8cpp}{Island\+Collision.\+cpp}\end{DoxyCompactItemize}
