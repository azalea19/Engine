\hypertarget{_interface2_d_8cpp}{}\section{C\+:/\+Users/elizabeth/\+Documents/\+Git\+Hub/\+Engine/\+Open\+G\+L\+Engine/\+Open\+G\+L\+Engine/\+Interface2D.cpp File Reference}
\label{_interface2_d_8cpp}\index{C\+:/\+Users/elizabeth/\+Documents/\+Git\+Hub/\+Engine/\+Open\+G\+L\+Engine/\+Open\+G\+L\+Engine/\+Interface2\+D.\+cpp@{C\+:/\+Users/elizabeth/\+Documents/\+Git\+Hub/\+Engine/\+Open\+G\+L\+Engine/\+Open\+G\+L\+Engine/\+Interface2\+D.\+cpp}}
{\ttfamily \#include \char`\"{}Interface2\+D.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}S\+D\+L.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}Screen.\+h\char`\"{}}\\*
{\ttfamily \#include $<$stdio.\+h$>$}\\*
{\ttfamily \#include $<$G\+L/glew.\+h$>$}\\*
{\ttfamily \#include \char`\"{}Shader\+Library.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}S\+D\+L\+\_\+image.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}S\+D\+L\+\_\+ttf.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}Shader.\+h\char`\"{}}\\*
Include dependency graph for Interface2\+D.\+cpp\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_interface2_d_8cpp__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static uint32\+\_\+t $\ast$ \hyperlink{_interface2_d_8cpp_aef9ea7aa7108fafa8483e9975eae9524}{Get\+Pixel\+Data} (S\+D\+L\+\_\+\+Surface $\ast$source)
\item 
S\+D\+L\+\_\+\+Surface $\ast$ \hyperlink{_interface2_d_8cpp_a7772d7b358cc73373b31a284a014daf6}{Get\+Surface\+From\+Img} (const \hyperlink{_types_8h_ad453f9f71ce1f9153fb748d6bb25e454}{string} \&file\+Path)
\item 
uint32\+\_\+t $\ast$ \hyperlink{_interface2_d_8cpp_a70ff1352d96df5ed263078f22ba7f739}{Get\+Img\+Data} (const \hyperlink{_types_8h_ad453f9f71ce1f9153fb748d6bb25e454}{string} \&file\+Path)
\item 
\hyperlink{_types_8h_a43182e59794291f6ab00e51b160706c2}{vec2} \hyperlink{_interface2_d_8cpp_a402c4feb9594fd3a9d206b0a1bd8e239}{Get\+Image\+Dimensions} (S\+D\+L\+\_\+\+Surface $\ast$surface)
\item 
void \hyperlink{_interface2_d_8cpp_a64188d961d6f6898ef2e28672ea051a8}{Draw\+Text} (int size, \hyperlink{_types_8h_ad453f9f71ce1f9153fb748d6bb25e454}{string} const \&file\+Path, \hyperlink{_types_8h_ad453f9f71ce1f9153fb748d6bb25e454}{string} const \&text, int xpos, int ypos, \hyperlink{_types_8h_a3d0ce73e3199de81565fb01632415288}{vec3} const \&color)
\item 
void \hyperlink{_interface2_d_8cpp_ad64606697cf4bc26837399251006964f}{Draw\+Image} (\hyperlink{_types_8h_ad453f9f71ce1f9153fb748d6bb25e454}{string} const \&file\+Path)
\item 
static void \hyperlink{_interface2_d_8cpp_a8abdf154fb1cd8dac68a6031ed3bcc2b}{Break\+On\+G\+L\+Error} ()
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{Interface2\+D.\+cpp@{Interface2\+D.\+cpp}!Break\+On\+G\+L\+Error@{Break\+On\+G\+L\+Error}}
\index{Break\+On\+G\+L\+Error@{Break\+On\+G\+L\+Error}!Interface2\+D.\+cpp@{Interface2\+D.\+cpp}}
\subsubsection[{\texorpdfstring{Break\+On\+G\+L\+Error()}{BreakOnGLError()}}]{\setlength{\rightskip}{0pt plus 5cm}static void Break\+On\+G\+L\+Error (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{_interface2_d_8cpp_a8abdf154fb1cd8dac68a6031ed3bcc2b}{}\label{_interface2_d_8cpp_a8abdf154fb1cd8dac68a6031ed3bcc2b}


Definition at line 305 of file Interface2\+D.\+cpp.


\begin{DoxyCode}
306 \{
307     \textcolor{keywordtype}{int} error = glGetError();
308     \textcolor{keywordflow}{if} (error != 0)
309     \{
310         printf(\textcolor{stringliteral}{"Open GL error code: %d"}, error);
311         getchar();
312     \}
313 \}\end{DoxyCode}
\index{Interface2\+D.\+cpp@{Interface2\+D.\+cpp}!Draw\+Image@{Draw\+Image}}
\index{Draw\+Image@{Draw\+Image}!Interface2\+D.\+cpp@{Interface2\+D.\+cpp}}
\subsubsection[{\texorpdfstring{Draw\+Image(string const \&file\+Path)}{DrawImage(string const &filePath)}}]{\setlength{\rightskip}{0pt plus 5cm}void Draw\+Image (
\begin{DoxyParamCaption}
\item[{{\bf string} const \&}]{file\+Path}
\end{DoxyParamCaption}
)}\hypertarget{_interface2_d_8cpp_ad64606697cf4bc26837399251006964f}{}\label{_interface2_d_8cpp_ad64606697cf4bc26837399251006964f}


Definition at line 186 of file Interface2\+D.\+cpp.



References Get\+Pixel\+Data().


\begin{DoxyCode}
187 \{
188   SDL\_Surface* surface;
189 
190   surface = IMG\_Load(filePath.c\_str());
191 
192   \textcolor{comment}{//Render font to a SDL\_Surface}
193   \textcolor{keywordflow}{if} (surface == \textcolor{keyword}{nullptr})
194   \{
195     printf(\textcolor{stringliteral}{"Texture %s error could not render to surface."}, filePath);
196     getchar();
197     \textcolor{keywordflow}{return};
198   \}
199 
200   GLuint texId;
201 
202   \textcolor{comment}{//Generate OpenGL texture}
203   glGenTextures(1, &texId);
204   glBindTexture(GL\_TEXTURE\_2D, texId);
205 
206   \textcolor{comment}{//Avoid mipmap filtering}
207   glTexParameterf(GL\_TEXTURE\_2D, GL\_TEXTURE\_MAG\_FILTER, GL\_NEAREST);
208   glTexParameterf(GL\_TEXTURE\_2D, GL\_TEXTURE\_MIN\_FILTER, GL\_NEAREST);
209 
210 
211 
212   \textcolor{comment}{//Create a surface to the correct size in RGB format, and copy the old image}
213   SDL\_Surface * s = SDL\_CreateRGBSurface(0, surface->w, surface->h, 32, 0x00ff0000, 0x0000ff00, 0x000000ff,
       0xff000000);
214   SDL\_BlitSurface(surface, NULL, s, NULL);
215 
216   uint32\_t* pixData = \hyperlink{_interface2_d_8cpp_aef9ea7aa7108fafa8483e9975eae9524}{GetPixelData}(s);
217 
218   \textcolor{comment}{//Copy the created image into OpenGL format}
219   glTexImage2D(GL\_TEXTURE\_2D, 0, GL\_RGBA, s->w, s->h, 0, GL\_RGBA, GL\_UNSIGNED\_BYTE, pixData);
220 
221   \textcolor{keywordtype}{string} previousShader = \hyperlink{class_singleton_a74f32751d99bf3cc95fe17aba11f4b07}{ShaderLibrary::GetInstance}().
      \hyperlink{struct_shader_library_a2fb593add0c096c41787e67476e99e0c}{GetCurrentShaderName}();
222 
223   \hyperlink{class_singleton_a74f32751d99bf3cc95fe17aba11f4b07}{ShaderLibrary::GetInstance}().\hyperlink{struct_shader_library_addba2e2f925252895b9475381c837071}{BindShader}(\textcolor{stringliteral}{"orthoShader"});
224 
225   std::unique\_ptr<IShader> \textcolor{keyword}{const}& shader = \hyperlink{class_singleton_a74f32751d99bf3cc95fe17aba11f4b07}{ShaderLibrary::GetInstance}().
      \hyperlink{struct_shader_library_af15e65d4d0b648272428fc167a6d03b9}{CurrentShader}();
226 
227   GLuint gVBO;
228   GLuint gUVBO;
229 
230   \textcolor{comment}{//Y flipped in shader}
231   \textcolor{comment}{//Top left corner at 0,0}
232   \textcolor{keyword}{const} GLfloat g\_vertex\_buffer\_data[] =
233   \{
234     (float)(0),(float)(s->h), 0,
235     (float)(s->w),(float)(s->h), 0,
236     (float)(0), (float)(0), 0,
237 
238     (float)(s->w), (float)(s->h),   0,
239     (float)(s->w), (float)(0), 0,
240     (float)(0), (float)(0), 0
241   \};
242 
243   \textcolor{keyword}{const} GLfloat g\_uv\_buffer\_data[] =
244   \{
245     0,1,
246     1,1,
247     0,0,
248     1,1,
249     1,0,
250     0,0
251   \};
252 
253   glGenBuffers(1, &gVBO);
254   glBindBuffer(GL\_ARRAY\_BUFFER, gVBO);
255   glBufferData(GL\_ARRAY\_BUFFER, \textcolor{keyword}{sizeof}(g\_vertex\_buffer\_data), g\_vertex\_buffer\_data, GL\_STATIC\_DRAW);
256   glBindBuffer(GL\_ARRAY\_BUFFER, 0);
257 
258   \textcolor{comment}{//Handle the uv buffer}
259   glGenBuffers(1, &gUVBO);
260   glBindBuffer(GL\_ARRAY\_BUFFER, gUVBO);
261   glBufferData(GL\_ARRAY\_BUFFER, \textcolor{keyword}{sizeof}(g\_uv\_buffer\_data), g\_uv\_buffer\_data, GL\_STATIC\_DRAW);
262   glBindBuffer(GL\_ARRAY\_BUFFER, 0);
263 
264 
265   glDisable(GL\_DEPTH\_TEST);
266 
267   glEnable(GL\_TEXTURE\_2D);
268 
269   shader->TransmitUniform(\textcolor{stringliteral}{"width"}, \hyperlink{_screen_8h_a30da0e5a5d6ee95789dc562a4f495ba9}{GetScreenDimensions}().x);
270   shader->TransmitUniform(\textcolor{stringliteral}{"height"}, \hyperlink{_screen_8h_a30da0e5a5d6ee95789dc562a4f495ba9}{GetScreenDimensions}().y);
271 
272   glEnableVertexAttribArray(shader->Attribute(\textcolor{stringliteral}{"position"}));
273   glBindBuffer(GL\_ARRAY\_BUFFER, gVBO);
274   glVertexAttribPointer(shader->Attribute(\textcolor{stringliteral}{"position"}), 3, GL\_FLOAT, GL\_FALSE, 0, NULL);
275 
276 
277   glEnableVertexAttribArray(shader->Attribute(\textcolor{stringliteral}{"uvIn"}));
278   glBindBuffer(GL\_ARRAY\_BUFFER, gUVBO);
279   glVertexAttribPointer(shader->Attribute(\textcolor{stringliteral}{"uvIn"}), 2, GL\_FLOAT, GL\_FALSE, 0, NULL);
280 
281   glActiveTexture(GL\_TEXTURE0);
282   glBindTexture(GL\_TEXTURE\_2D, texId);
283 
284   shader->TransmitUniform(\textcolor{stringliteral}{"diffuse"}, 0);
285 
286   glDrawArrays(GL\_TRIANGLES, 0, 6);
287 
288   glFlush();
289 
290   glDisable(GL\_TEXTURE\_2D);
291   glEnable(GL\_DEPTH\_TEST);
292 
293   \hyperlink{class_singleton_a74f32751d99bf3cc95fe17aba11f4b07}{ShaderLibrary::GetInstance}().\hyperlink{struct_shader_library_addba2e2f925252895b9475381c837071}{BindShader}(previousShader);
294 
295   \textcolor{comment}{//Cleanup}
296   free(pixData);
297   SDL\_FreeSurface(s);
298   SDL\_FreeSurface(surface);
299   glDeleteTextures(1, &texId);
300   glDeleteBuffers(1, &gVBO);
301   glDeleteBuffers(1, &gUVBO);
302 
303 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=255pt]{_interface2_d_8cpp_ad64606697cf4bc26837399251006964f_cgraph}
\end{center}
\end{figure}


\index{Interface2\+D.\+cpp@{Interface2\+D.\+cpp}!Draw\+Text@{Draw\+Text}}
\index{Draw\+Text@{Draw\+Text}!Interface2\+D.\+cpp@{Interface2\+D.\+cpp}}
\subsubsection[{\texorpdfstring{Draw\+Text(int size, string const \&file\+Path, string const \&text, int xpos, int ypos, vec3 const \&color)}{DrawText(int size, string const &filePath, string const &text, int xpos, int ypos, vec3 const &color)}}]{\setlength{\rightskip}{0pt plus 5cm}void Draw\+Text (
\begin{DoxyParamCaption}
\item[{int}]{size, }
\item[{{\bf string} const \&}]{file\+Path, }
\item[{{\bf string} const \&}]{text, }
\item[{int}]{xpos, }
\item[{int}]{ypos, }
\item[{{\bf vec3} const \&}]{color}
\end{DoxyParamCaption}
)}\hypertarget{_interface2_d_8cpp_a64188d961d6f6898ef2e28672ea051a8}{}\label{_interface2_d_8cpp_a64188d961d6f6898ef2e28672ea051a8}


Definition at line 63 of file Interface2\+D.\+cpp.



References Get\+Pixel\+Data().


\begin{DoxyCode}
64 \{
65   \textcolor{comment}{//Load the font}
66   TTF\_Font *font = TTF\_OpenFont(filePath.c\_str(), size);
67 
68   \textcolor{keywordflow}{if} (font == \textcolor{keyword}{nullptr})
69   \{
70     printf(\textcolor{stringliteral}{"TTF\_OpenFont error, could not open font %s "}, filePath.c\_str());
71     getchar();
72     \textcolor{keywordflow}{return};
73   \}
74 
75   SDL\_Color colorFg = \{ uint8\_t(color.b * 255), uint8\_t(color.g * 255) , uint8\_t(color.r * 255) \};
76   SDL\_Surface *surface;
77 
78   \textcolor{comment}{//Render font to a SDL\_Surface}
79   \textcolor{keywordflow}{if} ((surface = TTF\_RenderText\_Blended(font, text.c\_str(), colorFg)) == \textcolor{keyword}{nullptr})
80   \{
81     TTF\_CloseFont(font);
82     printf(\textcolor{stringliteral}{"TTF\_OpenFont error could not render to surface."});
83     \textcolor{keywordflow}{return};
84   \}
85 
86   GLuint texId;
87 
88   \textcolor{comment}{//Generate OpenGL texture}
89   glGenTextures(1, &texId);
90   glBindTexture(GL\_TEXTURE\_2D, texId);
91 
92   \textcolor{comment}{//Avoid mipmap filtering}
93   glTexParameterf(GL\_TEXTURE\_2D, GL\_TEXTURE\_MAG\_FILTER, GL\_NEAREST);
94   glTexParameterf(GL\_TEXTURE\_2D, GL\_TEXTURE\_MIN\_FILTER, GL\_NEAREST);
95 
96   \textcolor{comment}{//Create a surface to the correct size in RGB format, and copy the old image}
97   SDL\_Surface * s = SDL\_CreateRGBSurface(0, surface->w, surface->h, 32, 0x00ff0000, 0x0000ff00, 0x000000ff,
       0xff000000);
98   SDL\_BlitSurface(surface, NULL, s, NULL);
99 
100   uint32\_t* pixData = \hyperlink{_interface2_d_8cpp_aef9ea7aa7108fafa8483e9975eae9524}{GetPixelData}(s);
101 
102   \textcolor{comment}{//Copy the created image into OpenGL format}
103   glTexImage2D(GL\_TEXTURE\_2D, 0, GL\_RGBA, surface->w, surface->h, 0, GL\_RGBA, GL\_UNSIGNED\_BYTE, pixData);
104 
105   \textcolor{keywordtype}{string} previousShader = \hyperlink{class_singleton_a74f32751d99bf3cc95fe17aba11f4b07}{ShaderLibrary::GetInstance}().
      \hyperlink{struct_shader_library_a2fb593add0c096c41787e67476e99e0c}{GetCurrentShaderName}();
106 
107   \hyperlink{class_singleton_a74f32751d99bf3cc95fe17aba11f4b07}{ShaderLibrary::GetInstance}().\hyperlink{struct_shader_library_addba2e2f925252895b9475381c837071}{BindShader}(\textcolor{stringliteral}{"orthoShader"});
108 
109   std::unique\_ptr<IShader> \textcolor{keyword}{const}& shader = \hyperlink{class_singleton_a74f32751d99bf3cc95fe17aba11f4b07}{ShaderLibrary::GetInstance}().
      \hyperlink{struct_shader_library_af15e65d4d0b648272428fc167a6d03b9}{CurrentShader}();
110 
111   GLuint gVBO;
112   GLuint gUVBO;
113 
114   \textcolor{keyword}{const} GLfloat g\_vertex\_buffer\_data[] =
115   \{
116     (float)(xpos),              (float)(ypos + surface->h),             0,
117     (float)(xpos + surface->w), (float)(ypos + surface->h),             0,
118     (float)(xpos),              (float)(ypos),                          0,
119     (float)(xpos + surface->w), (float)(ypos + surface->h),             0,
120     (float)(xpos + surface->w), (float)(ypos),                          0,
121     (float)(xpos),              (float)(ypos),                          0
122   \};
123 
124   \textcolor{keyword}{const} GLfloat g\_uv\_buffer\_data[] =
125   \{
126     0,1,
127     1,1,
128     0,0,
129     1,1,
130     1,0,
131     0,0
132   \};
133 
134 
135   glGenBuffers(1, &gVBO);
136   glBindBuffer(GL\_ARRAY\_BUFFER, gVBO);
137   glBufferData(GL\_ARRAY\_BUFFER, \textcolor{keyword}{sizeof}(g\_vertex\_buffer\_data), g\_vertex\_buffer\_data, GL\_STATIC\_DRAW);
138   glBindBuffer(GL\_ARRAY\_BUFFER, 0);
139 
140   \textcolor{comment}{//Handle the uv buffer}
141   glGenBuffers(1, &gUVBO);
142   glBindBuffer(GL\_ARRAY\_BUFFER, gUVBO);
143   glBufferData(GL\_ARRAY\_BUFFER, \textcolor{keyword}{sizeof}(g\_uv\_buffer\_data), g\_uv\_buffer\_data, GL\_STATIC\_DRAW);
144   glBindBuffer(GL\_ARRAY\_BUFFER, 0);
145 
146 
147   glDisable(GL\_DEPTH\_TEST);
148 
149   glEnable(GL\_TEXTURE\_2D);
150 
151 
152   glEnableVertexAttribArray(shader->Attribute(\textcolor{stringliteral}{"position"}));
153   glBindBuffer(GL\_ARRAY\_BUFFER, gVBO);
154   glVertexAttribPointer(shader->Attribute(\textcolor{stringliteral}{"position"}), 3, GL\_FLOAT, GL\_FALSE, 0, NULL);
155 
156 
157   glEnableVertexAttribArray(shader->Attribute(\textcolor{stringliteral}{"uvIn"}));
158   glBindBuffer(GL\_ARRAY\_BUFFER, gUVBO);
159   glVertexAttribPointer(shader->Attribute(\textcolor{stringliteral}{"uvIn"}), 2, GL\_FLOAT, GL\_FALSE, 0, NULL);
160 
161 
162   glActiveTexture(GL\_TEXTURE0);
163   glBindTexture(GL\_TEXTURE\_2D, texId);
164 
165   shader->TransmitUniform(\textcolor{stringliteral}{"diffuse"}, 0);
166 
167   glDrawArrays(GL\_TRIANGLES, 0, 6);
168 
169   glFlush();
170 
171   glDisable(GL\_TEXTURE\_2D);
172   glEnable(GL\_DEPTH\_TEST);
173 
174   \hyperlink{class_singleton_a74f32751d99bf3cc95fe17aba11f4b07}{ShaderLibrary::GetInstance}().\hyperlink{struct_shader_library_addba2e2f925252895b9475381c837071}{BindShader}(previousShader);
175 
176   \textcolor{comment}{//Cleanup}
177   TTF\_CloseFont(font);
178   SDL\_FreeSurface(s);
179   free(pixData);
180   SDL\_FreeSurface(surface);
181   glDeleteTextures(1, &texId);
182   glDeleteBuffers(1, &gVBO);
183   glDeleteBuffers(1, &gUVBO);
184 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=247pt]{_interface2_d_8cpp_a64188d961d6f6898ef2e28672ea051a8_cgraph}
\end{center}
\end{figure}


\index{Interface2\+D.\+cpp@{Interface2\+D.\+cpp}!Get\+Image\+Dimensions@{Get\+Image\+Dimensions}}
\index{Get\+Image\+Dimensions@{Get\+Image\+Dimensions}!Interface2\+D.\+cpp@{Interface2\+D.\+cpp}}
\subsubsection[{\texorpdfstring{Get\+Image\+Dimensions(\+S\+D\+L\+\_\+\+Surface $\ast$surface)}{GetImageDimensions(SDL_Surface *surface)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf vec2} Get\+Image\+Dimensions (
\begin{DoxyParamCaption}
\item[{S\+D\+L\+\_\+\+Surface $\ast$}]{surface}
\end{DoxyParamCaption}
)}\hypertarget{_interface2_d_8cpp_a402c4feb9594fd3a9d206b0a1bd8e239}{}\label{_interface2_d_8cpp_a402c4feb9594fd3a9d206b0a1bd8e239}


Definition at line 55 of file Interface2\+D.\+cpp.



Referenced by Height\+Map\+::\+Load\+Height\+Map().


\begin{DoxyCode}
56 \{
57   \hyperlink{_types_8h_a43182e59794291f6ab00e51b160706c2}{vec2} dim = \hyperlink{_types_8h_a43182e59794291f6ab00e51b160706c2}{vec2}(0);
58   dim.x = surface->w;
59   dim.y = surface->h;
60   \textcolor{keywordflow}{return} dim;
61 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_interface2_d_8cpp_a402c4feb9594fd3a9d206b0a1bd8e239_icgraph}
\end{center}
\end{figure}


\index{Interface2\+D.\+cpp@{Interface2\+D.\+cpp}!Get\+Img\+Data@{Get\+Img\+Data}}
\index{Get\+Img\+Data@{Get\+Img\+Data}!Interface2\+D.\+cpp@{Interface2\+D.\+cpp}}
\subsubsection[{\texorpdfstring{Get\+Img\+Data(const string \&file\+Path)}{GetImgData(const string &filePath)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t$\ast$ Get\+Img\+Data (
\begin{DoxyParamCaption}
\item[{const {\bf string} \&}]{file\+Path}
\end{DoxyParamCaption}
)}\hypertarget{_interface2_d_8cpp_a70ff1352d96df5ed263078f22ba7f739}{}\label{_interface2_d_8cpp_a70ff1352d96df5ed263078f22ba7f739}


Definition at line 42 of file Interface2\+D.\+cpp.



References Get\+Pixel\+Data(), and Get\+Surface\+From\+Img().


\begin{DoxyCode}
43 \{
44   SDL\_Surface* surface = \hyperlink{_interface2_d_8cpp_a7772d7b358cc73373b31a284a014daf6}{GetSurfaceFromImg}(filePath);
45 
46   \textcolor{comment}{//Create a surface to the correct size in RGB format, and copy the old image}
47   SDL\_Surface * s = SDL\_CreateRGBSurface(0, surface->w, surface->h, 32, 0x00ff0000, 0x0000ff00, 0x000000ff,
       0xff000000);
48   SDL\_BlitSurface(surface, NULL, s, NULL);
49 
50   uint32\_t* pixData = \hyperlink{_interface2_d_8cpp_aef9ea7aa7108fafa8483e9975eae9524}{GetPixelData}(s);
51 
52   \textcolor{keywordflow}{return} pixData;
53 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=288pt]{_interface2_d_8cpp_a70ff1352d96df5ed263078f22ba7f739_cgraph}
\end{center}
\end{figure}


\index{Interface2\+D.\+cpp@{Interface2\+D.\+cpp}!Get\+Pixel\+Data@{Get\+Pixel\+Data}}
\index{Get\+Pixel\+Data@{Get\+Pixel\+Data}!Interface2\+D.\+cpp@{Interface2\+D.\+cpp}}
\subsubsection[{\texorpdfstring{Get\+Pixel\+Data(\+S\+D\+L\+\_\+\+Surface $\ast$source)}{GetPixelData(SDL_Surface *source)}}]{\setlength{\rightskip}{0pt plus 5cm}static uint32\+\_\+t$\ast$ Get\+Pixel\+Data (
\begin{DoxyParamCaption}
\item[{S\+D\+L\+\_\+\+Surface $\ast$}]{source}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{_interface2_d_8cpp_aef9ea7aa7108fafa8483e9975eae9524}{}\label{_interface2_d_8cpp_aef9ea7aa7108fafa8483e9975eae9524}


Definition at line 11 of file Interface2\+D.\+cpp.


\begin{DoxyCode}
12 \{
13   uint32\_t* data = (uint32\_t*)malloc(\textcolor{keyword}{sizeof}(uint32\_t) * source->w * source->h);
14 
15   uint32\_t* dst = data;
16   uint8\_t* pixels = (uint8\_t*)(source->pixels);
17 
18   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} y = 0; y < source->h; y++)
19   \{
20     memcpy(dst, pixels, \textcolor{keyword}{sizeof}(uint32\_t) * source->w);
21     dst += source->w;
22     pixels += source->pitch;
23   \}
24 
25   \textcolor{keywordflow}{return} data;
26 \}
\end{DoxyCode}
\index{Interface2\+D.\+cpp@{Interface2\+D.\+cpp}!Get\+Surface\+From\+Img@{Get\+Surface\+From\+Img}}
\index{Get\+Surface\+From\+Img@{Get\+Surface\+From\+Img}!Interface2\+D.\+cpp@{Interface2\+D.\+cpp}}
\subsubsection[{\texorpdfstring{Get\+Surface\+From\+Img(const string \&file\+Path)}{GetSurfaceFromImg(const string &filePath)}}]{\setlength{\rightskip}{0pt plus 5cm}S\+D\+L\+\_\+\+Surface$\ast$ Get\+Surface\+From\+Img (
\begin{DoxyParamCaption}
\item[{const {\bf string} \&}]{file\+Path}
\end{DoxyParamCaption}
)}\hypertarget{_interface2_d_8cpp_a7772d7b358cc73373b31a284a014daf6}{}\label{_interface2_d_8cpp_a7772d7b358cc73373b31a284a014daf6}


Definition at line 28 of file Interface2\+D.\+cpp.



Referenced by Get\+Img\+Data().


\begin{DoxyCode}
29 \{
30   SDL\_Surface* surface;
31   surface = IMG\_Load(filePath.c\_str());
32 
33   \textcolor{keywordflow}{if} (surface == \textcolor{keyword}{nullptr})
34   \{
35     printf(\textcolor{stringliteral}{"Image %s error could not render to surface."}, filePath.c\_str());
36     getchar();
37     \textcolor{keywordflow}{return} 0;
38   \}
39   \textcolor{keywordflow}{return} surface;
40 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=288pt]{_interface2_d_8cpp_a7772d7b358cc73373b31a284a014daf6_icgraph}
\end{center}
\end{figure}


